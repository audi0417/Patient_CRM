# å¯¦æ–½éšæ®µè©³ç´°èªªæ˜

æœ¬æ–‡æª”è©³ç´°æè¿°ç—…æ‚£ CRM ç³»çµ±éš±ç§åˆè¦èˆ‡æ··åˆéƒ¨ç½²å°ˆæ¡ˆçš„å„éšæ®µå¯¦æ–½æ­¥é©Ÿã€‚

---

## ç›®éŒ„

1. [éšæ®µ 1ï¼šå®‰å…¨æ€§å¼·åŒ–](#éšæ®µ-1å®‰å…¨æ€§å¼·åŒ–)
2. [éšæ®µ 2ï¼šè³‡æ–™éš±ç§èˆ‡åŠ å¯†](#éšæ®µ-2è³‡æ–™éš±ç§èˆ‡åŠ å¯†)
3. [éšæ®µ 3ï¼šæ··åˆéƒ¨ç½²æ¶æ§‹](#éšæ®µ-3æ··åˆéƒ¨ç½²æ¶æ§‹)
4. [éšæ®µ 4ï¼šé€²éšåˆè¦åŠŸèƒ½](#éšæ®µ-4é€²éšåˆè¦åŠŸèƒ½)
5. [æª”æ¡ˆå½±éŸ¿ç¸½è¡¨](#æª”æ¡ˆå½±éŸ¿ç¸½è¡¨)

---

## éšæ®µ 1ï¼šå®‰å…¨æ€§å¼·åŒ–

**ç›®æ¨™**: ä¿®å¾©æ‰€æœ‰é—œéµå®‰å…¨æ¼æ´
**å·¥æœŸ**: 2 é€±
**å„ªå…ˆç´š**: ğŸ”´ ç·Šæ€¥
**ç‹€æ…‹**: æœªé–‹å§‹

### æ­¥é©Ÿ 1.1ï¼šå¯†ç¢¼é›œæ¹Šå¾ SHA256 é·ç§»è‡³ bcrypt

#### å½±éŸ¿æª”æ¡ˆ

| æª”æ¡ˆè·¯å¾‘ | è¡Œæ•¸ | è®Šæ›´é¡å‹ |
|---------|------|---------|
| `/server/routes/auth.js` | 33, 190, 208, 261, 279 | ä¿®æ”¹ |
| `/server/routes/organizations.js` | 227, 513, 588 | ä¿®æ”¹ |
| `/server/routes/users.js` | 80, 201 | ä¿®æ”¹ |
| `/server/database/db.js` | 131 | ä¿®æ”¹ |
| `/server/routes/seed.js` | 53 | ä¿®æ”¹ |
| `/server/utils/password.js` | - | **æ–°å»º** |

#### å¯¦ä½œæ­¥é©Ÿ

1. **å»ºç«‹å¯†ç¢¼å·¥å…·æ¨¡çµ„** (`server/utils/password.js`):

```javascript
const bcrypt = require('bcryptjs');
const crypto = require('crypto');

/**
 * ä½¿ç”¨ bcrypt é›œæ¹Šå¯†ç¢¼
 * @param {string} plaintext - æ˜æ–‡å¯†ç¢¼
 * @returns {Promise<string>} bcrypt é›œæ¹Šå€¼
 */
async function hashPassword(plaintext) {
  const saltRounds = 12;
  return await bcrypt.hash(plaintext, saltRounds);
}

/**
 * é©—è­‰å¯†ç¢¼ï¼ˆæ”¯æ´ bcrypt å’ŒèˆŠç‰ˆ SHA256ï¼‰
 * @param {string} plaintext - æ˜æ–‡å¯†ç¢¼
 * @param {string} hash - å„²å­˜çš„é›œæ¹Šå€¼
 * @returns {Promise<{isValid: boolean, needsRehash: boolean}>}
 */
async function verifyPassword(plaintext, hash) {
  // æª¢æŸ¥æ˜¯å¦ç‚º bcrypt æ ¼å¼ï¼ˆä»¥ $2a$, $2b$, $2y$ é–‹é ­ï¼‰
  if (hash.startsWith('$2a$') || hash.startsWith('$2b$') || hash.startsWith('$2y$')) {
    const isValid = await bcrypt.compare(plaintext, hash);
    return { isValid, needsRehash: false };
  }

  // èˆŠç‰ˆ SHA256 æ ¼å¼ï¼ˆå‘ä¸‹ç›¸å®¹ï¼‰
  const sha256Hash = crypto.createHash('sha256').update(plaintext).digest('hex');
  const isValid = sha256Hash === hash;

  return {
    isValid,
    needsRehash: isValid // å¦‚æœé©—è­‰æˆåŠŸï¼Œéœ€è¦é‡æ–°é›œæ¹Š
  };
}

module.exports = {
  hashPassword,
  verifyPassword
};
```

2. **ä¿®æ”¹ç™»å…¥é‚è¼¯** (`server/routes/auth.js`):

```javascript
const { hashPassword, verifyPassword } = require('../utils/password');

// ç™»å…¥ç«¯é»ï¼ˆç¬¬ 33 è¡Œé™„è¿‘ï¼‰
router.post('/login', loginLimiter, async (req, res) => {
  const { username, password } = req.body;

  try {
    const user = await db.query('SELECT * FROM users WHERE username = ?', [username]);

    if (!user) {
      await db.recordFailedLogin(username, req.ip);
      return res.status(401).json({ message: 'å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤' });
    }

    // ä½¿ç”¨æ–°çš„é©—è­‰å‡½å¼
    const { isValid, needsRehash } = await verifyPassword(password, user.password);

    if (!isValid) {
      await db.recordFailedLogin(username, req.ip);
      return res.status(401).json({ message: 'å¸³è™Ÿæˆ–å¯†ç¢¼éŒ¯èª¤' });
    }

    // å¦‚æœä½¿ç”¨èˆŠç‰ˆ SHA256ï¼Œé€æ˜åœ°é‡æ–°é›œæ¹Šç‚º bcrypt
    if (needsRehash) {
      const newHash = await hashPassword(password);
      await db.query('UPDATE users SET password = ? WHERE id = ?', [newHash, user.id]);
    }

    // é‡ç½®å¤±æ•—æ¬¡æ•¸ã€ç”¢ç”Ÿ JWT ç­‰...
    // ï¼ˆä¿ç•™åŸæœ‰é‚è¼¯ï¼‰
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  }
});

// ä¿®æ”¹å¯†ç¢¼ç«¯é»ï¼ˆç¬¬ 190 è¡Œé™„è¿‘ï¼‰
router.post('/change-password', authenticateToken, async (req, res) => {
  const { oldPassword, newPassword } = req.body;
  const userId = req.user.userId;

  try {
    const user = await db.query('SELECT * FROM users WHERE id = ?', [userId]);

    const { isValid } = await verifyPassword(oldPassword, user.password);
    if (!isValid) {
      return res.status(401).json({ message: 'èˆŠå¯†ç¢¼éŒ¯èª¤' });
    }

    // ä½¿ç”¨ bcrypt é›œæ¹Šæ–°å¯†ç¢¼
    const newHash = await hashPassword(newPassword);
    await db.query('UPDATE users SET password = ? WHERE id = ?', [newHash, userId]);

    res.json({ message: 'å¯†ç¢¼å·²æ›´æ–°' });
  } catch (error) {
    console.error('Change password error:', error);
    res.status(500).json({ message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  }
});
```

3. **ä¿®æ”¹ä½¿ç”¨è€…å»ºç«‹é‚è¼¯** (`server/routes/users.js`, `server/routes/organizations.js`):

æ›¿æ›æ‰€æœ‰ `crypto.createHash('sha256')` ç‚º `await hashPassword(password)`

4. **ä¿®æ”¹è³‡æ–™åº«åˆå§‹åŒ–** (`server/database/db.js`):

```javascript
const { hashPassword } = require('../utils/password');

async function initializeSuperAdmin() {
  const password = process.env.SUPER_ADMIN_PASSWORD || 'Admin123';
  const hashedPassword = await hashPassword(password);

  await db.run(`
    INSERT OR IGNORE INTO users (id, username, password, role, ...)
    VALUES (?, ?, ?, ?, ...)
  `, ['super-admin-id', 'admin', hashedPassword, 'super_admin', ...]);
}
```

#### æ¸¬è©¦æ¡ˆä¾‹

- âœ… æ–°ä½¿ç”¨è€…å»ºç«‹æ™‚å„²å­˜ bcrypt é›œæ¹Šï¼ˆä»¥ `$2a$` æˆ– `$2b$` é–‹é ­ï¼‰
- âœ… ä½¿ç”¨èˆŠç‰ˆ SHA256 å¯†ç¢¼ç™»å…¥æˆåŠŸä¸”è‡ªå‹•é‡æ–°é›œæ¹Šç‚º bcrypt
- âœ… ä½¿ç”¨ bcrypt å¯†ç¢¼ç™»å…¥æˆåŠŸ
- âœ… éŒ¯èª¤å¯†ç¢¼ç™»å…¥å¤±æ•—ï¼ˆå…©ç¨®é›œæ¹Šæ ¼å¼éƒ½æ¸¬è©¦ï¼‰
- âœ… ä¿®æ”¹å¯†ç¢¼å¾Œæ–°å¯†ç¢¼ç‚º bcrypt æ ¼å¼

#### æˆåŠŸæ¨™æº–

- [ ] ç¨‹å¼ç¢¼ä¸­ä¸å†å‡ºç¾ `crypto.createHash('sha256')` ç”¨æ–¼å¯†ç¢¼æ“ä½œ
- [ ] æ‰€æœ‰æ–°å»ºä½¿ç”¨è€…å¯†ç¢¼ç‚º bcrypt æ ¼å¼
- [ ] èˆŠä½¿ç”¨è€…ç™»å…¥å¾Œå¯†ç¢¼è‡ªå‹•å‡ç´šç‚º bcrypt
- [ ] æ‰€æœ‰å¯†ç¢¼ç›¸é—œæ¸¬è©¦é€šé

---

### æ­¥é©Ÿ 1.2ï¼šå¯¦ä½œç¨½æ ¸æ—¥èªŒç³»çµ±

#### æ–°å»ºæª”æ¡ˆ

| æª”æ¡ˆè·¯å¾‘ | ç”¨é€” |
|---------|------|
| `/server/middleware/auditLog.js` | ç¨½æ ¸æ—¥èªŒä¸­ä»‹å±¤ |
| `/server/services/auditService.js` | ç¨½æ ¸æ—¥èªŒæœå‹™é¡åˆ¥ |

#### Schema è®Šæ›´

ä¿®æ”¹ `/server/database/schema.js`ï¼Œæ–°å¢ç¨½æ ¸æ—¥èªŒè³‡æ–™è¡¨ï¼š

```javascript
const auditLogsTable = `
  CREATE TABLE IF NOT EXISTS audit_logs (
    id ${dialect === 'postgres' ? 'SERIAL PRIMARY KEY' : 'INTEGER PRIMARY KEY AUTOINCREMENT'},
    timestamp ${dialect === 'postgres' ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT CURRENT_TIMESTAMP,
    userId TEXT,
    username TEXT,
    userRole TEXT,
    organizationId TEXT,
    action TEXT NOT NULL,           -- CREATE, READ, UPDATE, DELETE, LOGIN, LOGOUT, EXPORT
    resource TEXT NOT NULL,         -- patients, consultations, users, etc.
    resourceId TEXT,                -- å—å½±éŸ¿è¨˜éŒ„çš„ ID
    details TEXT,                   -- JSON æ ¼å¼çš„é¡å¤–ä¸Šä¸‹æ–‡
    ipAddress TEXT,
    userAgent TEXT,
    status TEXT DEFAULT 'SUCCESS',  -- SUCCESS, FAILURE, DENIED
    errorMessage TEXT,
    FOREIGN KEY (organizationId) REFERENCES organizations(id) ON DELETE SET NULL
  );

  CREATE INDEX IF NOT EXISTS idx_audit_logs_timestamp ON audit_logs(timestamp DESC);
  CREATE INDEX IF NOT EXISTS idx_audit_logs_user ON audit_logs(userId, timestamp DESC);
  CREATE INDEX IF NOT EXISTS idx_audit_logs_org ON audit_logs(organizationId, timestamp DESC);
  CREATE INDEX IF NOT EXISTS idx_audit_logs_resource ON audit_logs(resource, resourceId);
  CREATE INDEX IF NOT EXISTS idx_audit_logs_action ON audit_logs(action, timestamp DESC);
`;
```

#### å¯¦ä½œç¨½æ ¸æœå‹™

`server/services/auditService.js`:

```javascript
const db = require('../database/adapters');

class AuditLogger {
  /**
   * è¨˜éŒ„ç¨½æ ¸æ—¥èªŒï¼ˆéåŒæ­¥ï¼Œä¸é˜»å¡ä¸»æµç¨‹ï¼‰
   */
  static async log({
    userId,
    username,
    userRole,
    organizationId,
    action,
    resource,
    resourceId,
    details = {},
    ipAddress,
    userAgent,
    status = 'SUCCESS',
    errorMessage = null
  }) {
    // ä½¿ç”¨ setImmediate ç¢ºä¿ä¸é˜»å¡ä¸»åŸ·è¡Œç·’
    setImmediate(async () => {
      try {
        await db.run(`
          INSERT INTO audit_logs (
            userId, username, userRole, organizationId,
            action, resource, resourceId, details,
            ipAddress, userAgent, status, errorMessage
          ) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
        `, [
          userId,
          username,
          userRole,
          organizationId,
          action,
          resource,
          resourceId,
          JSON.stringify(details),
          ipAddress,
          userAgent,
          status,
          errorMessage
        ]);
      } catch (error) {
        // ç¨½æ ¸æ—¥èªŒå¤±æ•—ä¸æ‡‰å½±éŸ¿ä¸»æµç¨‹ï¼Œåƒ…è¨˜éŒ„éŒ¯èª¤
        console.error('[AuditLogger] Failed to write audit log:', error);
      }
    });
  }

  /**
   * æŸ¥è©¢ç¨½æ ¸æ—¥èªŒ
   */
  static async query({ organizationId, userId, resource, action, startDate, endDate, limit = 100, offset = 0 }) {
    let query = 'SELECT * FROM audit_logs WHERE 1=1';
    const params = [];

    if (organizationId) {
      query += ' AND organizationId = ?';
      params.push(organizationId);
    }

    if (userId) {
      query += ' AND userId = ?';
      params.push(userId);
    }

    if (resource) {
      query += ' AND resource = ?';
      params.push(resource);
    }

    if (action) {
      query += ' AND action = ?';
      params.push(action);
    }

    if (startDate) {
      query += ' AND timestamp >= ?';
      params.push(startDate);
    }

    if (endDate) {
      query += ' AND timestamp <= ?';
      params.push(endDate);
    }

    query += ' ORDER BY timestamp DESC LIMIT ? OFFSET ?';
    params.push(limit, offset);

    return await db.all(query, params);
  }
}

module.exports = AuditLogger;
```

#### å¯¦ä½œä¸­ä»‹å±¤

`server/middleware/auditLog.js`:

```javascript
const AuditLogger = require('../services/auditService');

/**
 * ç¨½æ ¸ä¸­ä»‹å±¤ï¼šæ³¨å…¥ audit() å¹«åŠ©å‡½å¼åˆ° req ç‰©ä»¶
 */
function auditMiddleware(req, res, next) {
  req.audit = (action, resource, resourceId, details = {}, status = 'SUCCESS', errorMessage = null) => {
    const user = req.user || {};

    AuditLogger.log({
      userId: user.userId,
      username: user.username,
      userRole: user.role,
      organizationId: user.organizationId,
      action,
      resource,
      resourceId,
      details,
      ipAddress: req.ip,
      userAgent: req.headers['user-agent'],
      status,
      errorMessage
    });
  };

  next();
}

module.exports = auditMiddleware;
```

#### æ•´åˆè‡³è·¯ç”±

ä¿®æ”¹ `/server/index.js`:

```javascript
const auditMiddleware = require('./middleware/auditLog');

// åœ¨ authenticateToken ä¹‹å¾Œå¥—ç”¨
app.use(auditMiddleware);
```

ä¿®æ”¹ `/server/routes/patients.js` ç­‰è·¯ç”±ï¼ŒåŠ å…¥ç¨½æ ¸è¨˜éŒ„ï¼š

```javascript
// å»ºç«‹ç—…æ‚£
router.post('/', authenticateToken, async (req, res) => {
  try {
    const result = await req.TenantQuery.insert('patients', patientData);

    // è¨˜éŒ„ç¨½æ ¸æ—¥èªŒ
    req.audit('CREATE', 'patients', result.id, { name: patientData.name });

    res.json(result);
  } catch (error) {
    req.audit('CREATE', 'patients', null, {}, 'FAILURE', error.message);
    res.status(500).json({ message: 'å»ºç«‹å¤±æ•—' });
  }
});

// æŸ¥çœ‹ç—…æ‚£è©³æƒ…
router.get('/:id', authenticateToken, async (req, res) => {
  const patient = await req.TenantQuery.findById('patients', req.params.id);

  req.audit('READ', 'patients', req.params.id);

  res.json(patient);
});

// æ›´æ–°ç—…æ‚£
router.put('/:id', authenticateToken, async (req, res) => {
  await req.TenantQuery.update('patients', req.params.id, updatedData);

  req.audit('UPDATE', 'patients', req.params.id, {
    changedFields: Object.keys(updatedData)
  });

  res.json({ message: 'æ›´æ–°æˆåŠŸ' });
});

// åˆªé™¤ç—…æ‚£
router.delete('/:id', authenticateToken, checkRole(['admin']), async (req, res) => {
  await req.TenantQuery.delete('patients', req.params.id);

  req.audit('DELETE', 'patients', req.params.id);

  res.json({ message: 'åˆªé™¤æˆåŠŸ' });
});
```

åŒæ¨£æ¨¡å¼å¥—ç”¨è‡³ï¼š
- `/server/routes/health.js`
- `/server/routes/consultations.js`
- `/server/routes/users.js`
- `/server/routes/auth.js` (ç™»å…¥/ç™»å‡º)

#### æ–°å¢ç¨½æ ¸æ—¥èªŒæŸ¥è©¢ API

`server/routes/auditLogs.js` (æ–°å»º):

```javascript
const express = require('express');
const router = express.Router();
const { authenticateToken, checkRole } = require('../middleware/auth');
const AuditLogger = require('../services/auditService');

// æŸ¥è©¢ç¨½æ ¸æ—¥èªŒï¼ˆç®¡ç†å“¡é™å®šï¼‰
router.get('/', authenticateToken, checkRole(['admin', 'super_admin']), async (req, res) => {
  const { userId, resource, action, startDate, endDate, limit, offset } = req.query;

  try {
    // ä¸€èˆ¬ç®¡ç†å“¡åªèƒ½æŸ¥çœ‹è‡ªå·±çµ„ç¹”çš„æ—¥èªŒ
    const organizationId = req.user.role === 'super_admin' ? null : req.user.organizationId;

    const logs = await AuditLogger.query({
      organizationId,
      userId,
      resource,
      action,
      startDate,
      endDate,
      limit: parseInt(limit) || 100,
      offset: parseInt(offset) || 0
    });

    res.json(logs);
  } catch (error) {
    console.error('Query audit logs error:', error);
    res.status(500).json({ message: 'æŸ¥è©¢å¤±æ•—' });
  }
});

module.exports = router;
```

åœ¨ `server/index.js` è¨»å†Šè·¯ç”±ï¼š

```javascript
app.use('/api/audit-logs', require('./routes/auditLogs'));
```

#### æ¸¬è©¦æ¡ˆä¾‹

- âœ… CRUD æ“ä½œæœƒè‡ªå‹•è¨˜éŒ„ç¨½æ ¸æ—¥èªŒ
- âœ… ç¨½æ ¸æ—¥èªŒåŒ…å«å®Œæ•´è³‡è¨Šï¼ˆä½¿ç”¨è€…ã€æ“ä½œã€è³‡æºã€æ™‚é–“æˆ³ã€IPï¼‰
- âœ… ç¨½æ ¸æ—¥èªŒå¯«å…¥å¤±æ•—ä¸å½±éŸ¿ä¸»æ¥­å‹™æµç¨‹
- âœ… Admin åªèƒ½æŸ¥è©¢æœ¬çµ„ç¹”æ—¥èªŒ
- âœ… Super Admin å¯æŸ¥è©¢æ‰€æœ‰çµ„ç¹”æ—¥èªŒ

#### æˆåŠŸæ¨™æº–

- [ ] `audit_logs` è³‡æ–™è¡¨å»ºç«‹å®Œæˆ
- [ ] æ‰€æœ‰ç—…æ‚£è³‡æ–™ CRUD æ“ä½œéƒ½æœ‰ç¨½æ ¸è¨˜éŒ„
- [ ] èªè­‰æ“ä½œï¼ˆç™»å…¥ã€ç™»å‡ºã€å¯†ç¢¼è®Šæ›´ï¼‰æœ‰ç¨½æ ¸è¨˜éŒ„
- [ ] ç¨½æ ¸æ—¥èªŒæŸ¥è©¢ API æ­£å¸¸é‹ä½œ

---

### æ­¥é©Ÿ 1.3ï¼šç§»é™¤ Super Admin è·¨çµ„ç¹” PII ç«¯é»

#### å½±éŸ¿æª”æ¡ˆ

| æª”æ¡ˆè·¯å¾‘ | è¡Œæ•¸ | è®Šæ›´é¡å‹ |
|---------|------|---------|
| `/server/routes/superadmin.js` | 585-616 | ä¿®æ”¹/ç§»é™¤ |

#### å¯¦ä½œæ­¥é©Ÿ

1. **ç§»é™¤æˆ–é™åˆ¶ `/api/superadmin/patients` ç«¯é»**:

```javascript
// åŸæœ‰ç«¯é»ï¼ˆç§»é™¤ï¼‰ï¼š
// router.get('/patients', authenticateToken, checkSuperAdmin, async (req, res) => { ... });

// æ›¿æ›ç‚ºçµ±è¨ˆç«¯é»ï¼š
router.get('/patients/stats', authenticateToken, checkSuperAdmin, async (req, res) => {
  try {
    const stats = await db.all(`
      SELECT
        o.id AS organizationId,
        o.name AS organizationName,
        COUNT(p.id) AS patientCount,
        COUNT(CASE WHEN DATE(p.createdAt) >= DATE('now', '-30 days') THEN 1 END) AS patientsLast30Days,
        COUNT(CASE WHEN DATE(p.createdAt) >= DATE('now', '-7 days') THEN 1 END) AS patientsLast7Days
      FROM organizations o
      LEFT JOIN patients p ON p.organizationId = o.id
      GROUP BY o.id, o.name
      ORDER BY patientCount DESC
    `);

    req.audit('READ', 'patients_stats', null, { organizationCount: stats.length });

    res.json(stats);
  } catch (error) {
    console.error('Get patient stats error:', error);
    res.status(500).json({ message: 'æŸ¥è©¢å¤±æ•—' });
  }
});
```

2. **å¦‚æœç¢ºå¯¦éœ€è¦å­˜å–å€‹åˆ¥ç—…æ‚£è³‡æ–™ï¼ˆé™¤éŒ¯ç”¨é€”ï¼‰ï¼ŒåŠ å…¥ç’°å¢ƒè®Šæ•¸æ§åˆ¶**:

`.env`:
```
ENABLE_SUPERADMIN_PII_ACCESS=false
```

`server/routes/superadmin.js`:
```javascript
// åƒ…åœ¨æ˜ç¢ºå•Ÿç”¨æ™‚æ‰å…è¨±å­˜å–
if (process.env.ENABLE_SUPERADMIN_PII_ACCESS === 'true') {
  router.get('/patients/debug', authenticateToken, checkSuperAdmin, async (req, res) => {
    // è¨˜éŒ„é«˜é¢¨éšªç¨½æ ¸æ—¥èªŒ
    req.audit('READ', 'patients', null, {
      warning: 'SUPERADMIN_PII_ACCESS',
      reason: req.query.reason || 'not_specified'
    });

    // è¿”å›ç—…æ‚£è³‡æ–™ï¼ˆåƒ…ç”¨æ–¼ç³»çµ±é™¤éŒ¯ï¼‰
    const patients = await db.all('SELECT * FROM patients LIMIT 100');
    res.json(patients);
  });
}
```

#### æ¸¬è©¦æ¡ˆä¾‹

- âœ… `/api/superadmin/patients` ç«¯é»å·²ç§»é™¤æˆ–å—ç’°å¢ƒè®Šæ•¸ä¿è­·
- âœ… `/api/superadmin/patients/stats` è¿”å›åŒ¯ç¸½çµ±è¨ˆï¼Œç„¡å€‹åˆ¥ç—…æ‚£ PII
- âœ… å¦‚æœ‰ debug ç«¯é»ï¼Œæ¯æ¬¡å­˜å–éƒ½æœ‰ç¨½æ ¸è¨˜éŒ„

#### æˆåŠŸæ¨™æº–

- [ ] Super Admin ç„¡æ³•é€é API ç›´æ¥å–å¾—è·¨çµ„ç¹”ç—…æ‚£å€‹è³‡
- [ ] çµ±è¨ˆç«¯é»æ­£å¸¸é‹ä½œ
- [ ] å¦‚æœ‰ debug ç«¯é»ï¼Œé è¨­åœç”¨ä¸”æœ‰å®Œæ•´ç¨½æ ¸è¿½è¹¤

---

### æ­¥é©Ÿ 1.4ï¼šå¼·åŒ– TenantQuery åŸç”ŸæŸ¥è©¢æª¢æŸ¥

#### å½±éŸ¿æª”æ¡ˆ

| æª”æ¡ˆè·¯å¾‘ | è¡Œæ•¸ | è®Šæ›´é¡å‹ |
|---------|------|---------|
| `/server/middleware/tenantContext.js` | 255 | ä¿®æ”¹ |

#### å¯¦ä½œæ­¥é©Ÿ

ä¿®æ”¹ `TenantQuery.raw()` çš„æª¢æŸ¥é‚è¼¯ï¼š

```javascript
// åŸå§‹ç‰ˆæœ¬ï¼ˆå¯ç¹éï¼‰ï¼š
raw: (query, params) => {
  if (!query.toLowerCase().includes('organizationid')) {
    throw new Error('Raw query must include organizationId filter for tenant isolation');
  }
  return adapter.raw(query, params);
}

// å¼·åŒ–ç‰ˆæœ¬ï¼š
raw: (query, params) => {
  const lowerQuery = query.toLowerCase();

  // æª¢æŸ¥æ˜¯å¦åœ¨ WHERE å­å¥ä¸­ä½¿ç”¨ organizationId
  const hasWhereClause = /where\s+.*(organizationid|"organizationid")\s*=/.test(lowerQuery);

  if (!hasWhereClause) {
    console.error('[TenantQuery] Raw query missing organizationId filter:', query);
    throw new Error('Raw query must include organizationId in WHERE clause for tenant isolation');
  }

  // é©—è­‰ params ä¸­æ˜¯å¦åŒ…å« organizationId
  if (!params.includes(req.user.organizationId)) {
    console.error('[TenantQuery] Raw query params missing organizationId:', params);
    throw new Error('Raw query params must include current organizationId');
  }

  // è¨˜éŒ„è­¦å‘Šï¼ˆæ‡‰ç›¡é‡é¿å…ä½¿ç”¨ rawï¼‰
  console.warn('[TenantQuery] Raw query used:', {
    user: req.user.username,
    organizationId: req.user.organizationId,
    query: query.substring(0, 100) // åƒ…è¨˜éŒ„å‰ 100 å­—å…ƒ
  });

  return adapter.raw(query, params);
}
```

#### æ¸¬è©¦æ¡ˆä¾‹

- âœ… `SELECT organizationId FROM patients` è¢«æ‹’çµ•ï¼ˆæ²’æœ‰ WHERE éæ¿¾ï¼‰
- âœ… `SELECT * FROM patients WHERE organizationId = ?` ä¸” params åŒ…å«æ­£ç¢º organizationId æ™‚å…è¨±
- âœ… params ä¸åŒ…å« organizationId æ™‚è¢«æ‹’çµ•
- âœ… æ‰€æœ‰ raw æŸ¥è©¢éƒ½æœ‰è­¦å‘Šæ—¥èªŒ

#### æˆåŠŸæ¨™æº–

- [ ] ç„¡ WHERE éæ¿¾çš„ raw æŸ¥è©¢è¢«æ‹’çµ•
- [ ] params ä¸åŒ…å« organizationId çš„æŸ¥è©¢è¢«æ‹’çµ•
- [ ] ç¾æœ‰ä½¿ç”¨ raw çš„ç¨‹å¼ç¢¼ç¶“å¯©æŸ¥å¾Œéƒ½ç¬¦åˆè¦ç¯„

---

### æ­¥é©Ÿ 1.5ï¼šJWT å®‰å…¨æ€§æ”¹é€²

#### å½±éŸ¿æª”æ¡ˆ

| æª”æ¡ˆè·¯å¾‘ | è®Šæ›´é¡å‹ |
|---------|---------|
| `/server/middleware/auth.js` | ä¿®æ”¹ |
| `/server/routes/auth.js` | ä¿®æ”¹ |
| `/src/lib/api.ts` | ä¿®æ”¹ï¼ˆå‰ç«¯ï¼‰ |

#### Schema è®Šæ›´

æ–°å¢ refresh token å’Œ token é»‘åå–®è³‡æ–™è¡¨ï¼š

```javascript
const refreshTokensTable = `
  CREATE TABLE IF NOT EXISTS refresh_tokens (
    id ${dialect === 'postgres' ? 'SERIAL PRIMARY KEY' : 'INTEGER PRIMARY KEY AUTOINCREMENT'},
    userId TEXT NOT NULL,
    token TEXT NOT NULL UNIQUE,
    expiresAt ${dialect === 'postgres' ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL,
    createdAt ${dialect === 'postgres' ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (userId) REFERENCES users(id) ON DELETE CASCADE
  );

  CREATE INDEX IF NOT EXISTS idx_refresh_tokens_user ON refresh_tokens(userId);
  CREATE INDEX IF NOT EXISTS idx_refresh_tokens_expires ON refresh_tokens(expiresAt);
`;

const tokenBlacklistTable = `
  CREATE TABLE IF NOT EXISTS token_blacklist (
    jti TEXT PRIMARY KEY,
    expiresAt ${dialect === 'postgres' ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL,
    createdAt ${dialect === 'postgres' ? 'TIMESTAMPTZ' : 'DATETIME'} NOT NULL DEFAULT CURRENT_TIMESTAMP
  );

  CREATE INDEX IF NOT EXISTS idx_token_blacklist_expires ON token_blacklist(expiresAt);
`;
```

#### å¯¦ä½œæ­¥é©Ÿ

1. **ç”¢ç”Ÿ Access Token æ™‚åŠ å…¥ jti (JWT ID)**:

`server/routes/auth.js`:
```javascript
const crypto = require('crypto');

// ç™»å…¥æˆåŠŸå¾Œ
const jti = crypto.randomBytes(16).toString('hex');
const token = jwt.sign(
  {
    userId: user.id,
    username: user.username,
    role: user.role,
    organizationId: user.organizationId,
    jti
  },
  process.env.JWT_SECRET,
  { expiresIn: '4h' } // å¾ 24h ç¸®çŸ­è‡³ 4h
);

// åŒæ™‚ç”¢ç”Ÿ refresh token
const refreshToken = crypto.randomBytes(32).toString('hex');
const refreshExpiresAt = new Date(Date.now() + 7 * 24 * 60 * 60 * 1000); // 7 å¤©

await db.run(`
  INSERT INTO refresh_tokens (userId, token, expiresAt)
  VALUES (?, ?, ?)
`, [user.id, refreshToken, refreshExpiresAt]);

res.json({
  token,
  refreshToken,
  user: { /* ... */ }
});
```

2. **å¯¦ä½œ refresh ç«¯é»**:

```javascript
router.post('/refresh', async (req, res) => {
  const { refreshToken } = req.body;

  try {
    const tokenRecord = await db.query(`
      SELECT * FROM refresh_tokens
      WHERE token = ? AND expiresAt > datetime('now')
    `, [refreshToken]);

    if (!tokenRecord) {
      return res.status(401).json({ message: 'Invalid or expired refresh token' });
    }

    const user = await db.query('SELECT * FROM users WHERE id = ?', [tokenRecord.userId]);

    // ç”¢ç”Ÿæ–°çš„ access token
    const jti = crypto.randomBytes(16).toString('hex');
    const newToken = jwt.sign(
      {
        userId: user.id,
        username: user.username,
        role: user.role,
        organizationId: user.organizationId,
        jti
      },
      process.env.JWT_SECRET,
      { expiresIn: '4h' }
    );

    req.audit('REFRESH_TOKEN', 'auth', user.id);

    res.json({ token: newToken });
  } catch (error) {
    console.error('Refresh token error:', error);
    res.status(500).json({ message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  }
});
```

3. **å¯¦ä½œç™»å‡ºï¼ˆæ’¤éŠ· tokenï¼‰**:

```javascript
router.post('/logout', authenticateToken, async (req, res) => {
  const { jti } = req.user;
  const { refreshToken } = req.body;

  try {
    // å°‡ access token åŠ å…¥é»‘åå–®
    const expiresAt = new Date(Date.now() + 4 * 60 * 60 * 1000); // 4 å°æ™‚å¾ŒéæœŸ
    await db.run(`
      INSERT INTO token_blacklist (jti, expiresAt)
      VALUES (?, ?)
    `, [jti, expiresAt]);

    // åˆªé™¤ refresh token
    if (refreshToken) {
      await db.run('DELETE FROM refresh_tokens WHERE token = ?', [refreshToken]);
    }

    req.audit('LOGOUT', 'auth', req.user.userId);

    res.json({ message: 'ç™»å‡ºæˆåŠŸ' });
  } catch (error) {
    console.error('Logout error:', error);
    res.status(500).json({ message: 'ä¼ºæœå™¨éŒ¯èª¤' });
  }
});
```

4. **ä¿®æ”¹ authenticateToken ä¸­ä»‹å±¤æª¢æŸ¥é»‘åå–®**:

`server/middleware/auth.js`:
```javascript
async function authenticateToken(req, res, next) {
  const token = req.headers['authorization']?.split(' ')[1];

  if (!token) {
    return res.status(401).json({ message: 'æœªæä¾› token' });
  }

  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);

    // æª¢æŸ¥ token æ˜¯å¦åœ¨é»‘åå–®
    const isBlacklisted = await db.query(
      'SELECT 1 FROM token_blacklist WHERE jti = ?',
      [decoded.jti]
    );

    if (isBlacklisted) {
      return res.status(403).json({ message: 'Token å·²æ’¤éŠ·' });
    }

    req.user = decoded;
    next();
  } catch (error) {
    return res.status(403).json({ message: 'Token ç„¡æ•ˆæˆ–å·²éæœŸ' });
  }
}
```

5. **å‰ç«¯è™•ç† token refresh**:

ä¿®æ”¹ `src/lib/api.ts`:
```typescript
// å„²å­˜ refresh token
function setRefreshToken(token: string) {
  localStorage.setItem('hospital_crm_refresh_token', token);
}

function getRefreshToken(): string | null {
  return localStorage.getItem('hospital_crm_refresh_token');
}

// API è«‹æ±‚æ””æˆªå™¨
async function apiRequest(endpoint: string, options: RequestInit = {}) {
  let response = await fetch(`${API_BASE_URL}${endpoint}`, {
    ...options,
    headers: {
      ...options.headers,
      'Authorization': `Bearer ${getAuthToken()}`
    }
  });

  // å¦‚æœ 401 ä¸”æœ‰ refresh tokenï¼Œå˜—è©¦åˆ·æ–°
  if (response.status === 401 && getRefreshToken()) {
    const refreshResponse = await fetch(`${API_BASE_URL}/api/auth/refresh`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ refreshToken: getRefreshToken() })
    });

    if (refreshResponse.ok) {
      const { token } = await refreshResponse.json();
      setAuthToken(token);

      // é‡è©¦åŸå§‹è«‹æ±‚
      response = await fetch(`${API_BASE_URL}${endpoint}`, {
        ...options,
        headers: {
          ...options.headers,
          'Authorization': `Bearer ${token}`
        }
      });
    } else {
      // Refresh å¤±æ•—ï¼Œæ¸…é™¤æ‰€æœ‰ token ä¸¦å°å‘ç™»å…¥é 
      logout();
      window.location.href = '/login';
    }
  }

  return response;
}
```

6. **å®šæœŸæ¸…ç†éæœŸé»‘åå–®å’Œ refresh token**:

æ–°å¢ cron job åˆ° `server/services/cronJobs.js`:
```javascript
// æ¯æ—¥æ¸…ç†éæœŸ token
cron.schedule('0 2 * * *', async () => {
  console.log('[Cron] Cleaning expired tokens...');

  await db.run(`DELETE FROM token_blacklist WHERE expiresAt < datetime('now')`);
  await db.run(`DELETE FROM refresh_tokens WHERE expiresAt < datetime('now')`);

  console.log('[Cron] Token cleanup completed');
});
```

#### æ¸¬è©¦æ¡ˆä¾‹

- âœ… ç™»å…¥å¾Œå–å¾— access tokenï¼ˆ4hï¼‰å’Œ refresh tokenï¼ˆ7dï¼‰
- âœ… Access token éæœŸå¾Œä½¿ç”¨ refresh token å–å¾—æ–° token
- âœ… ç™»å‡ºå¾Œ token è¢«åŠ å…¥é»‘åå–®ä¸”ç„¡æ³•ä½¿ç”¨
- âœ… è¢«æ’¤éŠ·çš„ token å›å‚³ 403
- âœ… éæœŸ token è‡ªå‹•æ¸…ç†

#### æˆåŠŸæ¨™æº–

- [ ] JWT æœ‰æ•ˆæœŸå¾ 24h ç¸®çŸ­è‡³ 4h
- [ ] Refresh token æ©Ÿåˆ¶æ­£å¸¸é‹ä½œ
- [ ] ç™»å‡ºå¾Œ token ç«‹å³å¤±æ•ˆ
- [ ] å‰ç«¯è‡ªå‹•è™•ç† token åˆ·æ–°

---

## éšæ®µ 2ï¼šè³‡æ–™éš±ç§èˆ‡åŠ å¯†

**ç›®æ¨™**: æ•æ„Ÿè³‡æ–™åŠ å¯†ã€åŒæ„è¿½è¹¤ã€ä¿ç•™æ”¿ç­–
**å·¥æœŸ**: 3 é€±
**å„ªå…ˆç´š**: ğŸ”´ é«˜
**å‰ç½®æ¢ä»¶**: éšæ®µ 1 å®Œæˆ
**ç‹€æ…‹**: æœªé–‹å§‹

### æ­¥é©Ÿ 2.1ï¼šæ•æ„Ÿå¥åº·è³‡æ–™æ¬„ä½åŠ å¯†

è©³ç´°å…§å®¹è«‹åƒé–±ä¸»è¦åŠƒæ–‡æª”ç¬¬ 5 ç« ç¯€ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:
- ä½¿ç”¨ AES-256-GCM åŠ å¯†
- å–®çµ„ç¹”é‡‘é‘°è¡ç”Ÿï¼ˆHKDFï¼‰
- é€æ˜åŠ è§£å¯†ï¼ˆæ‡‰ç”¨å±¤ï¼‰
- é·ç§»ç­–ç•¥ï¼ˆæ¼¸é€²å¼ï¼‰

---

### æ­¥é©Ÿ 2.2ï¼šPostgreSQL Row-Level Security

è©³ç´°å…§å®¹è«‹åƒé–±ä¸»è¦åŠƒæ–‡æª”ç¬¬ 5 ç« ç¯€ã€‚

**æ ¸å¿ƒæ¦‚å¿µ**:
- è³‡æ–™åº«å±¤é˜²ç¦¦
- åƒ…é©ç”¨æ–¼ PostgreSQL
- SET app.current_org_id
- æ”¿ç­–æ¸¬è©¦

---

### æ­¥é©Ÿ 2.3ï¼šè³‡æ–™åˆ†é¡èˆ‡å­˜å–æ§åˆ¶çŸ©é™£

è©³ç´°å…§å®¹è«‹åƒé–±ä¸»è¦åŠƒæ–‡æª”ç¬¬ 5 ç« ç¯€ã€‚

**è³‡æ–™åˆ†é¡å±¤ç´š**:
- PUBLIC
- INTERNAL
- CONFIDENTIAL
- RESTRICTED

---

### æ­¥é©Ÿ 2.4ï¼šç—…æ‚£åŒæ„è¿½è¹¤

è©³ç´°å…§å®¹è«‹åƒé–±ä¸»è¦åŠƒæ–‡æª”ç¬¬ 5 ç« ç¯€ã€‚

**åŒæ„é¡å‹**:
- è³‡æ–™è’é›†åŒæ„
- è³‡æ–™è™•ç†åŒæ„
- è¡ŒéŠ·åŒæ„
- è·¨å¢ƒå‚³è¼¸åŒæ„

---

### æ­¥é©Ÿ 2.5ï¼šä½¿ç”¨ç›®çš„é™åˆ¶è¿½è¹¤

è©³ç´°å…§å®¹è«‹åƒé–±ä¸»è¦åŠƒæ–‡æª”ç¬¬ 5 ç« ç¯€ã€‚

**æ¨™æº–ç›®çš„**:
- è‡¨åºŠç…§è­·
- é ç´„ç®¡ç†
- è¨ˆè²»
- å ±è¡¨
- ç³»çµ±ç®¡ç†

---

### æ­¥é©Ÿ 2.6ï¼šè³‡æ–™ä¿ç•™æ”¿ç­–å¼•æ“

è©³ç´°å…§å®¹è«‹åƒé–±ä¸»è¦åŠƒæ–‡æª”ç¬¬ 5 ç« ç¯€ã€‚

**ä¿ç•™å‹•ä½œ**:
- åŒ¿ååŒ–
- åˆªé™¤
- æ­¸æª”

**æ³•è¦è¦æ±‚**:
- é†«ç™‚ç´€éŒ„ â‰¥ 7 å¹´
- æœªæˆå¹´ â‰¥ 10 å¹´

---

## éšæ®µ 3ï¼šæ··åˆéƒ¨ç½²æ¶æ§‹

**ç›®æ¨™**: æ”¯æ´æœ¬åœ°ã€é›²ç«¯ã€æ··åˆéƒ¨ç½²
**å·¥æœŸ**: 4 é€±
**å„ªå…ˆç´š**: ğŸŸ  ä¸­
**å‰ç½®æ¢ä»¶**: éšæ®µ 1 å®Œæˆ
**ç‹€æ…‹**: æœªé–‹å§‹

è©³ç´°å…§å®¹è«‹åƒé–±ä¸»è¦åŠƒæ–‡æª”ç¬¬ 4 ç« ç¯€ã€‚

---

## éšæ®µ 4ï¼šé€²éšåˆè¦åŠŸèƒ½

**ç›®æ¨™**: å®Œæ•´æ³•è¦åˆè¦èˆ‡è‡ªåŠ©åŠŸèƒ½
**å·¥æœŸ**: 3-4 é€±
**å„ªå…ˆç´š**: ğŸŸ¡ ä½
**å‰ç½®æ¢ä»¶**: éšæ®µ 2ã€3 å®Œæˆ
**ç‹€æ…‹**: æœªé–‹å§‹

è©³ç´°å…§å®¹è«‹åƒé–±ä¸»è¦åŠƒæ–‡æª”ç¬¬ 5 ç« ç¯€ã€‚

---

## æª”æ¡ˆå½±éŸ¿ç¸½è¡¨

| å…ƒä»¶ | æª”æ¡ˆè·¯å¾‘ | éšæ®µ | è®Šæ›´é¡å‹ |
|------|---------|------|---------|
| å‰ç«¯èªè­‰ | `/src/contexts/AuthContext.tsx` | 1 | ä¿®æ”¹ï¼ˆtoken refreshï¼‰ |
| èªè­‰é‚è¼¯ | `/src/lib/auth.ts` | 1 | ä¿®æ”¹ï¼ˆrefresh tokenï¼‰ |
| API å®¢æˆ¶ç«¯ | `/src/lib/api.ts` | 1 | ä¿®æ”¹ï¼ˆ401 è™•ç†ã€refreshï¼‰ |
| å¾Œç«¯èªè­‰ | `/server/routes/auth.js` | 1 | ä¿®æ”¹ï¼ˆbcryptã€refreshã€jtiï¼‰ |
| ä½¿ç”¨è€…è·¯ç”± | `/server/routes/users.js` | 1 | ä¿®æ”¹ï¼ˆbcryptï¼‰ |
| çµ„ç¹”è·¯ç”± | `/server/routes/organizations.js` | 1 | ä¿®æ”¹ï¼ˆbcryptï¼‰ |
| ç—…æ‚£è·¯ç”± | `/server/routes/patients.js` | 1, 2 | ä¿®æ”¹ï¼ˆç¨½æ ¸ã€åŠ å¯†ï¼‰ |
| Super Admin | `/server/routes/superadmin.js` | 1 | ä¿®æ”¹ï¼ˆç§»é™¤ PIIï¼‰ |
| Seed è·¯ç”± | `/server/routes/seed.js` | 1 | ä¿®æ”¹ï¼ˆbcryptï¼‰ |
| å¥åº·ç´€éŒ„ | `/server/routes/health.js` | 1, 2 | ä¿®æ”¹ï¼ˆç¨½æ ¸ã€åŠ å¯†ï¼‰ |
| è¨ºç™‚è¨˜éŒ„ | `/server/routes/consultations.js` | 2 | ä¿®æ”¹ï¼ˆåŠ å¯†ã€ç¨½æ ¸ï¼‰ |
| èªè­‰ä¸­ä»‹å±¤ | `/server/middleware/auth.js` | 1 | ä¿®æ”¹ï¼ˆblacklist æª¢æŸ¥ï¼‰ |
| ç§Ÿæˆ¶ä¸­ä»‹å±¤ | `/server/middleware/tenantContext.js` | 1, 2 | ä¿®æ”¹ï¼ˆraw æª¢æŸ¥ã€åŠ å¯†ï¼‰ |
| æ¨¡çµ„å­˜å–ä¸­ä»‹å±¤ | `/server/middleware/moduleAccess.js` | 3 | ä¿®æ”¹ï¼ˆéƒ¨ç½²æ¨¡å¼æ„ŸçŸ¥ï¼‰ |
| Schema | `/server/database/schema.js` | 1, 2 | ä¿®æ”¹ï¼ˆæ–°è³‡æ–™è¡¨ï¼‰ |
| DB åˆå§‹åŒ– | `/server/database/db.js` | 1 | ä¿®æ”¹ï¼ˆsuper admin bcryptï¼‰ |
| PostgreSQL ä»‹é¢ | `/server/database/adapters/postgres.js` | 2 | ä¿®æ”¹ï¼ˆRLS æ”¯æ´ï¼‰ |
| åŠ å¯†å·¥å…· | `/server/utils/encryption.js` | 2 | æ“´å±•ï¼ˆçµ„ç¹”é‡‘é‘°è¡ç”Ÿï¼‰ |
| Cron Jobs | `/server/services/cronJobs.js` | 1, 2 | ä¿®æ”¹ï¼ˆtoken æ¸…ç†ã€ä¿ç•™ï¼‰ |
| ä¼ºæœå™¨ä¸»æª” | `/server/index.js` | 1, 2, 3 | ä¿®æ”¹ï¼ˆæ–°è·¯ç”±ã€è¨­å®šï¼‰ |
| Electron ä¸»ç¨‹åº | `/electron/main.js` | 3 | å¤§å¹…æ”¹å¯«ï¼ˆå…§åµŒä¼ºæœå™¨ï¼‰ |
| **å¯†ç¢¼å·¥å…·** | `/server/utils/password.js` | 1 | **æ–°å»º** |
| **ç¨½æ ¸ä¸­ä»‹å±¤** | `/server/middleware/auditLog.js` | 1 | **æ–°å»º** |
| **ç¨½æ ¸æœå‹™** | `/server/services/auditService.js` | 1 | **æ–°å»º** |
| **ç¨½æ ¸è·¯ç”±** | `/server/routes/auditLogs.js` | 1 | **æ–°å»º** |
| **æ¬„ä½åŠ å¯†** | `/server/utils/fieldEncryption.js` | 2 | **æ–°å»º** |
| **è³‡æ–™åº«éš”é›¢** | `/server/database/isolation.js` | 2 | **æ–°å»º** |
| **è³‡æ–™åˆ†é¡** | `/server/config/dataClassification.js` | 2 | **æ–°å»º** |
| **éƒ¨ç½²é…ç½®** | `/server/config/deployment.js` | 3 | **æ–°å»º** |
| **ä¿ç•™æ”¿ç­–** | `/server/config/retentionPolicies.js` | 2 | **æ–°å»º** |
| **ä¿ç•™æœå‹™** | `/server/services/retentionService.js` | 2 | **æ–°å»º** |
| **åŒæ­¥æœå‹™** | `/server/services/syncService.js` | 3 | **æ–°å»º** |
| **å‚™ä»½æœå‹™** | `/server/services/backupService.js` | 3 | **æ–°å»º** |
| **ç•°å¸¸åµæ¸¬** | `/server/services/breachDetection.js` | 3 | **æ–°å»º** |
| **ç®¡ç†è·¯ç”±** | `/server/routes/management.js` | 3 | **æ–°å»º** |
| **Electron æ©‹æ¥** | `/electron/server-bridge.js` | 3 | **æ–°å»º** |

---

**æ–‡æª”ç‰ˆæœ¬**: 1.0
**æœ€å¾Œæ›´æ–°**: 2026-01-30

# 欄位加密功能遷移指引

## 概述

本文檔說明如何將現有系統從明文儲存遷移至欄位級加密儲存。欄位加密功能使用 **AES-256-GCM** 演算法和 **HKDF 組織金鑰衍生**，確保每個組織的資料使用獨立金鑰加密。

**版本**: 1.0
**日期**: 2026-01-30
**狀態**: 實施指引

---

## 目錄

1. [加密功能說明](#加密功能說明)
2. [前置準備](#前置準備)
3. [漸進式遷移策略](#漸進式遷移策略)
4. [環境變數設定](#環境變數設定)
5. [測試加密功能](#測試加密功能)
6. [遷移步驟](#遷移步驟)
7. [驗證與回滾](#驗證與回滾)
8. [常見問題](#常見問題)

---

## 加密功能說明

### 已加密的敏感欄位

#### patients 表
- `medicalHistory` - 醫療病史
- `allergies` - 過敏史
- `emergencyContact` - 緊急聯絡人

#### consultations 表
- `chiefComplaint` - 主訴
- `assessment` - 評估
- `plan` - 處置計劃
- `notes` - 備註

### 技術規格

- **演算法**: AES-256-GCM
- **金鑰衍生**: HKDF-SHA256
- **組織隔離**: 每個組織使用獨立的衍生金鑰
- **IV 長度**: 16 bytes（隨機生成）
- **Auth Tag 長度**: 16 bytes
- **密文格式**: `iv:authTag:encrypted`（hex 編碼）

### 向後相容性

系統支援**混合模式**：
- 既有的明文資料可以正常讀取
- 新建/更新的資料會自動加密
- 讀取時會自動判斷是否需要解密
- `_encrypted` 欄位記錄哪些欄位已加密

---

## 前置準備

### 1. 備份資料庫

⚠️ **重要：在進行任何操作前務必完整備份資料庫**

#### SQLite 備份
```bash
# 備份資料庫文件
cp server/database/hospital_crm.db server/database/hospital_crm.db.backup-$(date +%Y%m%d-%H%M%S)

# 驗證備份完整性
sqlite3 server/database/hospital_crm.db.backup-* "PRAGMA integrity_check;"
```

#### PostgreSQL 備份
```bash
# 完整備份
pg_dump -h localhost -U username -d database_name -F c -f backup-$(date +%Y%m%d-%H%M%S).dump

# 僅備份 patients 和 consultations 表
pg_dump -h localhost -U username -d database_name -t patients -t consultations -F c -f sensitive-tables-backup.dump
```

### 2. 檢查資料庫 Schema

確保 `patients` 和 `consultations` 表已有 `_encrypted` 欄位：

```sql
-- SQLite
PRAGMA table_info(patients);
PRAGMA table_info(consultations);

-- PostgreSQL
\d patients
\d consultations
```

如果沒有 `_encrypted` 欄位，執行以下 SQL：

```sql
-- 為 patients 表新增 _encrypted 欄位
ALTER TABLE patients ADD COLUMN _encrypted TEXT;

-- 為 consultations 表新增 _encrypted 欄位
ALTER TABLE consultations ADD COLUMN _encrypted TEXT;
```

### 3. 安裝依賴

確保已安裝 Node.js 加密模組：

```bash
npm install
```

---

## 環境變數設定

### 生成安全的加密金鑰

```bash
# 使用 Node.js 生成 64 字元的隨機金鑰
node -e "console.log(require('crypto').randomBytes(32).toString('hex'))"
```

### 設定環境變數

在 `.env` 文件中新增：

```bash
# 加密主金鑰（必須至少 32 個字元）
ENCRYPTION_KEY=your-64-character-random-key-here
```

⚠️ **金鑰管理注意事項：**
- 金鑰一旦設定後**不可更改**，否則無法解密既有資料
- 務必妥善保管金鑰，建議額外備份到安全位置
- 不同環境（開發、測試、生產）應使用不同的金鑰
- 切勿將金鑰提交到版本控制系統

### 金鑰備份建議

```bash
# 將金鑰加密後備份
echo "ENCRYPTION_KEY=$(grep ENCRYPTION_KEY .env | cut -d= -f2)" | \
gpg --symmetric --cipher-algo AES256 -o encryption-key-backup.gpg
```

---

## 測試加密功能

在進行遷移前，先測試加密功能是否正常：

```bash
# 執行測試腳本
node server/utils/test-encryption.js
```

預期輸出：
```
✅ 所有測試通過！加密功能正常運作

📋 測試總結:
  ✅ 加密金鑰有效
  ✅ 單一欄位加密/解密正常
  ✅ 組織金鑰隔離有效
  ✅ 批次欄位加密正常
  ✅ 批次欄位解密正常
  ✅ 空值處理正確
  ✅ 組織金鑰衍生正常
```

如果測試失敗，請檢查：
1. `ENCRYPTION_KEY` 是否正確設定
2. 金鑰長度是否至少 32 個字元
3. 依賴套件是否正確安裝

---

## 漸進式遷移策略

系統採用**自動漸進式遷移**，無需手動轉換既有資料：

### 遷移模式

1. **寫入時加密**: 所有新建/更新的記錄自動加密
2. **讀取時解密**: 自動判斷並解密已加密的欄位
3. **混合相容**: 明文和密文可以共存

### 遷移時間軸

| 階段 | 說明 | 狀態 |
|------|------|------|
| 階段 0 | 所有資料為明文 | 遷移前 |
| 階段 1 | 啟用加密功能，新資料加密，舊資料明文 | 混合模式 |
| 階段 2 | 隨著資料更新，逐漸轉為加密 | 逐步遷移中 |
| 階段 3 | 所有活躍資料已加密 | 遷移完成 |

---

## 遷移步驟

### 步驟 1：啟用加密功能

1. 確保 `.env` 已設定 `ENCRYPTION_KEY`
2. 確保資料庫 Schema 已更新（有 `_encrypted` 欄位）
3. 重啟伺服器

```bash
# 停止伺服器
# 視您的啟動方式而定，例如：
pm2 stop hospital-crm
# 或
kill $(cat server.pid)

# 啟動伺服器
npm run server
```

### 步驟 2：驗證新資料加密

1. 登入系統
2. 建立一個測試患者，填寫敏感欄位
3. 直接查詢資料庫，確認資料已加密

```sql
-- 查詢最新患者的敏感欄位
SELECT id, name,
       SUBSTR(medicalHistory, 1, 50) as medicalHistory_sample,
       SUBSTR(allergies, 1, 50) as allergies_sample,
       _encrypted
FROM patients
ORDER BY createdAt DESC
LIMIT 1;
```

預期看到：
- `medicalHistory_sample`: 類似 `a3b5c7...`（hex 格式）
- `_encrypted`: `["medicalHistory","allergies","emergencyContact"]`

### 步驟 3：測試讀取功能

1. 在前端讀取剛才建立的患者
2. 確認顯示為明文（系統已自動解密）
3. 檢查伺服器日誌，確認無解密錯誤

### 步驟 4：監控混合模式運作

在混合模式下，系統會：
- 讀取明文資料時：直接返回
- 讀取密文資料時：自動解密後返回
- 更新資料時：重新加密後儲存

監控指令：
```bash
# 查看伺服器日誌
tail -f server/logs/app.log | grep Encryption

# 統計加密欄位數量
sqlite3 hospital_crm.db "SELECT COUNT(*) FROM patients WHERE _encrypted IS NOT NULL;"
```

### 步驟 5：完整遷移（可選）

如果希望立即加密所有既有資料，可以執行批次遷移腳本（需自行開發）。

範例腳本架構：
```javascript
const { queryAll, execute } = require('./server/database/helpers');
const { encryptFields } = require('./server/utils/fieldEncryption');

async function migratePatients(organizationId) {
  // 1. 查詢所有未加密的患者
  const patients = await queryAll(
    'SELECT * FROM patients WHERE organizationId = ? AND _encrypted IS NULL',
    [organizationId]
  );

  // 2. 逐一加密並更新
  for (const patient of patients) {
    const { data, encrypted } = encryptFields(
      patient,
      ['medicalHistory', 'allergies', 'emergencyContact'],
      organizationId
    );

    await execute(
      'UPDATE patients SET medicalHistory = ?, allergies = ?, emergencyContact = ?, _encrypted = ? WHERE id = ?',
      [data.medicalHistory, data.allergies, data.emergencyContact, JSON.stringify(encrypted), patient.id]
    );
  }
}
```

---

## 驗證與回滾

### 驗證檢查清單

- [ ] 新建患者記錄資料已加密
- [ ] 更新患者記錄資料已重新加密
- [ ] 前端顯示資料正確（已解密）
- [ ] 既有明文資料仍可正常讀取
- [ ] 組織間資料隔離有效（無法跨組織解密）
- [ ] 無解密錯誤日誌
- [ ] 效能無明顯下降

### 回滾策略

如果遇到嚴重問題需要回滾：

#### 方案 A：暫時停用加密（保留密文）

1. 移除加密中介層
2. 修改路由，不調用加密/解密函式
3. 密文資料會以密文形式顯示（但不會影響系統運作）

#### 方案 B：完整回滾（僅適用於早期發現問題）

1. 停止伺服器
2. 還原資料庫備份

```bash
# SQLite
cp server/database/hospital_crm.db.backup-YYYYMMDD-HHMMSS server/database/hospital_crm.db

# PostgreSQL
pg_restore -h localhost -U username -d database_name -c backup.dump
```

3. 移除 `.env` 中的 `ENCRYPTION_KEY`
4. 重啟伺服器

---

## 常見問題

### Q1: 如果更改了 ENCRYPTION_KEY 會怎樣？

A: **絕對不能更改**已使用的 `ENCRYPTION_KEY`。更改後會導致：
- 所有已加密的資料無法解密
- 系統拋出解密錯誤
- 患者資料將永久無法存取

### Q2: 加密會影響效能嗎？

A: 加密/解密操作會增加少量 CPU 負載，但影響極小：
- 單一欄位加密：< 1ms
- 批次欄位加密：< 5ms
- 對於正常的 CRUD 操作，使用者感受不到差異

### Q3: 如何處理金鑰遺失？

A: 金鑰遺失無法復原。預防措施：
- 定期備份金鑰到安全位置
- 使用加密金鑰管理系統（如 AWS KMS、Azure Key Vault）
- 建立金鑰復原流程
- 記錄金鑰備份位置和復原步驟

### Q4: 能否對單一組織更換金鑰？

A: 技術上可行，但需要：
1. 使用舊金鑰解密所有資料
2. 使用新金鑰重新加密
3. 更新金鑰衍生邏輯

建議：除非金鑰洩露，否則不建議更換金鑰。

### Q5: 加密資料會增加儲存空間嗎？

A: 是的，加密後資料會增加約 **60-80%** 的儲存空間：
- IV: 32 字元（hex）
- Auth Tag: 32 字元（hex）
- 密文：略大於原始明文
- 分隔符號：2 個冒號

範例：
- 原始明文：「高血壓病史 10 年」（10 bytes）
- 加密後：約 80-100 bytes

### Q6: 如何驗證加密是否正常運作？

A: 執行測試腳本：
```bash
node server/utils/test-encryption.js
```

或手動測試：
1. 建立測試患者並填寫敏感欄位
2. 直接查詢資料庫確認為密文
3. 前端讀取確認顯示為明文

### Q7: 系統升級後是否需要重新加密？

A: 不需要。加密格式和演算法保持向下相容。除非：
- 需要升級加密演算法（如從 AES-256-GCM 升級到更強演算法）
- 需要更換金鑰（如金鑰洩露）

---

## 支援與聯繫

如有任何問題或需要協助，請聯繫：
- 技術支援：tech-support@example.com
- 緊急聯繫：+886-xxx-xxxxxx

---

**文檔版本**: 1.0
**最後更新**: 2026-01-30
**維護者**: 系統架構團隊
